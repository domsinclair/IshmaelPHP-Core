#!/usr/bin/env php
<?php
    declare(strict_types=1);

    /**
     * Ishmael Core CLI (Composer bin)
     *
     * This CLI is distribution‑safe: it does not reference SkeletonApp. It resolves the
     * end‑user application's Composer autoload, loads its config, and dispatches to the
     * programmatic Core APIs (Migrator, SeedManager).
     *
     * Commands:
     *  - ish help
     *  - ish make:module <Name> [--templates=PATH]
     *  - ish make:migration <name> [--module=Name]
     *  - ish migrate [--module=Name] [--steps=N] [--pretend]
     *  - ish migrate:rollback [--module=Name] [--steps=N]
     *  - ish status [--module=Name]
     *  - ish seed [--module=Name] [--class=FQCN] [--force] [--env=ENV]
     *  - ish key:generate [--force]
     */

    use Ishmael\Core\Database;
    use Ishmael\Core\Database\Migrations\Migrator;
    use Ishmael\Core\Database\Seeding\SeedManager;
    use Ishmael\Core\ModuleManager;

    /**
     * Locate the Composer autoloader.
     *
     * Search strategy:
     * 1) <appRoot>/vendor/autoload.php (when invoked from project root)
     * 2) vendor/.. hops for installed package locations
     *
     * @param string $appRoot Caller app root (usually getcwd()).
     * @return string Absolute path to autoload.php
     */
    function resolveAutoloadPath(string $appRoot): string
    {
        $candidates = [
                $appRoot . DIRECTORY_SEPARATOR . 'vendor' . DIRECTORY_SEPARATOR . 'autoload.php',
            // When executed as vendor/bin/ish inside a Composer project
                __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'autoload.php',
                __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'autoload.php',
        ];
        foreach ($candidates as $path) {
            if (is_file($path)) {
                return $path;
            }
        }
        fwrite(STDERR, "Unable to locate Composer autoload.php. Run 'composer install'.\n");
        exit(1);
    }

    /**
     * Parse command‑line options of the form --key=value and boolean flags like --pretend.
     *
     * @param array<int,string> $argv Raw argv list (excluding the command itself is fine)
     * @return array<string,mixed> Parsed options
     */
    function parseOptions(array $argv): array
    {
        $options = [];
        foreach ($argv as $arg) {
            if (str_starts_with($arg, '--')) {
                $arg = substr($arg, 2);
                if (str_contains($arg, '=')) {
                    [$k, $v] = explode('=', $arg, 2);
                    $options[$k] = $v;
                } else {
                    $options[$arg] = true; // boolean flag
                }
            }
        }
        return $options;
    }

    /**
     * Convert a string to StudlyCase (PascalCase).
     *
     * @param string $value Input string
     * @return string StudlyCase string
     */
    function toStudlyCase(string $value): string
    {
        $value = str_replace(['-', '_'], ' ', $value);
        $value = ucwords(strtolower($value));
        return str_replace(' ', '', $value);
    }

    /**
     * Convert a string to snake_case.
     *
     * @param string $value Input string
     * @return string snake_case string
     */
    function toSnake(string $value): string
    {
        $value = preg_replace('/[^a-zA-Z0-9]+/', ' ', $value) ?? $value;
        $value = trim($value);
        $value = preg_replace('/([a-z])([A-Z])/', '$1_$2', $value) ?? $value;
        $value = strtolower(str_replace(' ', '_', $value));
        return $value;
    }

    /**
     * Ensure a directory exists; create recursively if missing.
     *
     * @param string $path Directory path
     * @return void
     */
    function ensureDirectory(string $path): void
    {
        if (!is_dir($path)) {
            if (!mkdir($path, 0777, true) && !is_dir($path)) {
                throw new RuntimeException('Failed to create directory: ' . $path);
            }
        }
    }

    /**
     * Refuse to overwrite files unless explicitly allowed.
     *
     * @param string $path File path
     * @param string $contents File contents
     * @param bool $overwrite Whether to allow overwriting existing file
     * @return void
     */
    function writeFile(string $path, string $contents, bool $overwrite = false): void
    {
        if (file_exists($path) && !$overwrite) {
            throw new RuntimeException('File already exists: ' . $path);
        }
        ensureDirectory(dirname($path));
        $bytes = file_put_contents($path, $contents);
        if ($bytes === false) {
            throw new RuntimeException('Failed to write file: ' . $path);
        }
    }

    /**
     * Copy a directory tree recursively.
     *
     * @param string $source Source directory
     * @param string $destination Destination directory
     * @return void
     */
    function copyDirectoryRecursive(string $source, string $destination): void
    {
        if (!is_dir($source)) {
            throw new RuntimeException('Template directory not found: ' . $source);
        }
        ensureDirectory($destination);
        $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($source, FilesystemIterator::SKIP_DOTS),
                RecursiveIteratorIterator::SELF_FIRST
        );
        foreach ($iterator as $item) {
            $destPath = $destination . DIRECTORY_SEPARATOR . $iterator->getSubPathName();
            if ($item->isDir()) {
                ensureDirectory($destPath);
            } else {
                $contents = file_get_contents($item->getPathname());
                if ($contents === false) {
                    throw new RuntimeException('Failed to read template file: ' . $item->getPathname());
                }
                writeFile($destPath, $contents);
            }
        }
    }

    /**
     * Create the contents of a new migration file.
     *
     * @param string $className Class name for the migration
     * @param string $table Optional table name hint
     * @return string PHP file contents
     */
    function createMigrationContent(string $className, string $table = ''): string
    {
        $tableComment = $table !== '' ? " // Table: {$table}" : '';
        $now = date('Y-m-d H:i:s');
        return <<<PHP
<?php
declare(strict_types=1);

use Ishmael\\Core\\Database\\Migrations\\BaseMigration;
use Ishmael\\Core\\Database\\Schema\\Schema;
use Ishmael\\Core\\Database\\Schema\\Blueprint;

/**
 * Auto-generated migration{$tableComment}
 * Generated at {$now}
 */
final class {$className} extends BaseMigration
{
    /**
     * Apply the migration.
     * @return void
     */
    public function up(): void
    {
        // Example:
        // Schema::create('table_name', function (Blueprint $table): void {
        //     $table->id();
        //     $table->string('name', 191);
        //     $table->timestamps();
        // });
    }

    /**
     * Revert the migration.
     * @return void
     */
    public function down(): void
    {
        // Example:
        // Schema::dropIfExists('table_name');
    }
}
PHP;
    }

    // 1) Resolve app root and autoload
    $appRoot = getcwd();
    // Hint base_path() to use the host application's root rather than the vendor package path
    if (!defined('ISH_APP_BASE')) {
        define('ISH_APP_BASE', $appRoot);
    }
    // Also expose via server/env for any components that look it up this way
    $_SERVER['ISH_APP_BASE'] = $appRoot;
    $autoload = resolveAutoloadPath($appRoot);

    // Guard to prevent HTTP router dispatch
    if (!defined('ISH_BOOTSTRAP_ONLY')) {
        define('ISH_BOOTSTRAP_ONLY', true);
    }

    require $autoload; // app vendor/autoload.php

    // Determine command early
    $command = $argv[1] ?? 'help';

    // 2) Load database config from app unless overridden (only for commands that need DB)
    $options = parseOptions(array_slice($argv, 2));
    $nonDbCommands = [
            'help','make:module','make:resource','make:view','make:views','make:controller','make:service',
            'examples:list','examples:install','pack','make:routes',
            'modules:cache','modules:clear','route:cache','route:clear'
    ];
    if (!in_array($command, $nonDbCommands, true)) {
        $configPath = isset($options['config']) ? (string)$options['config'] : ($appRoot . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR . 'database.php');
        if (!is_file($configPath)) {
            fwrite(STDERR, 'Database config not found at: ' . $configPath . PHP_EOL);
            exit(1);
        }
        $databaseConfig = require $configPath;

        // 3) Boot Core and initialize DB
        if (!class_exists(Database::class)) {
            // In case Core requires a bootstrap, try a relative path within the package
            $maybeBootstrap = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'bootstrap' . DIRECTORY_SEPARATOR . 'app.php';
            if (is_file($maybeBootstrap)) {
                require $maybeBootstrap;
            }
        }
        Database::init($databaseConfig);
    }

    // 4) Resolve template directory order (app overrides → core stubs)
    /**
     * Resolve a template bundle directory by name.
     * Lookup order: <appRoot>/app/stubs/<Name> → <appRoot>/Templates/<Name> → <core>/Resources/stubs/<Name>.
     *
     * @param string $name Template bundle name (e.g., 'Module')
     * @param string $appRoot Application root
     * @param string|null $override Optional absolute override via --templates
     * @return string Resolved directory path
     */
    function resolveTemplateDir(string $name, string $appRoot, ?string $override = null): string
    {
        if ($override !== null) {
            if (!is_dir($override)) {
                throw new RuntimeException('Templates override not found: ' . $override);
            }
            return $override;
        }
        $appStubs = $appRoot . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'stubs' . DIRECTORY_SEPARATOR . $name;
        if (is_dir($appStubs)) {
            return $appStubs;
        }
        $appTpl = $appRoot . DIRECTORY_SEPARATOR . 'Templates' . DIRECTORY_SEPARATOR . $name;
        if (is_dir($appTpl)) {
            return $appTpl;
        }
        $coreTpl = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'Resources' . DIRECTORY_SEPARATOR . 'stubs' . DIRECTORY_SEPARATOR . $name;
        if (is_dir($coreTpl)) {
            return $coreTpl;
        }
        throw new RuntimeException("No templates found for '{$name}'.");
    }

    /**
     * Replace template tokens in a string.
     *
     * @param string $contents Template contents
     * @param array<string,string> $vars Map of token => value
     * @return string
     */
    function replaceTokens(string $contents, array $vars): string
    {
        foreach ($vars as $k => $v) {
            $contents = str_replace('<' . $k . '>', $v, $contents);
        }
        return $contents;
    }

    /**
     * Persist CLI command metadata for docs generation.
     * Writes to <appRoot>/storage/cli_commands.json.
     *
     * @param string $appRoot
     * @param array<int, array{name:string, description:string, options:array<int, array{name:string, description:string, accepts?:string}>}> $commands
     * @return void
     */
    function persistCliMetadata(string $appRoot, array $commands): void
    {
        $dir = $appRoot . DIRECTORY_SEPARATOR . 'storage';
        ensureDirectory($dir);
        $path = $dir . DIRECTORY_SEPARATOR . 'cli_commands.json';
        $json = json_encode(['generatedAt' => date('c'), 'commands' => $commands], JSON_PRETTY_PRINT);
        if ($json === false) {
            return;
        }
        file_put_contents($path, $json);
    }

    /**
     * Return the command registry (name, description, options) for docs.
     *
     * @return array<int, array{name:string, description:string, options:array<int, array{name:string, description:string, accepts?:string}>}>
     */
    function cliCommandRegistry(): array
    {
        return [
                [
                        'name' => 'ui:tailwind',
                        'description' => 'Install Tailwind CSS (v4+) and scaffold CSS input/output for Ishmael.',
                        'options' => [
                                ['name' => '--css', 'description' => 'Input CSS path (default: resources\\css\\app.css)', 'accepts' => 'PATH'],
                                ['name' => '--out', 'description' => 'Output CSS path (default: public\\assets\\app.css)', 'accepts' => 'PATH'],
                                ['name' => '--force', 'description' => 'Overwrite existing files if present'],
                                ['name' => '--dry-run', 'description' => 'Print actions without making changes'],
                                ['name' => '--no-build', 'description' => 'Skip initial build step'],
                        ],
                ],
                [
                        'name' => 'help',
                        'description' => 'Show CLI usage and available commands.',
                        'options' => [
                                ['name' => '--config', 'description' => 'Path to database config file', 'accepts' => 'PATH'],
                                ['name' => '--templates', 'description' => 'Override templates directory', 'accepts' => 'PATH'],
                                ['name' => '--app-root', 'description' => 'Override application root', 'accepts' => 'PATH'],
                        ],
                ],
                [
                        'name' => 'make:module',
                        'description' => 'Scaffold a new module skeleton (controllers, models, views, routes.php, module.json).',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                                ['name' => '--api', 'description' => 'Hint API-style module (no session/CSRF route grouping)'],
                        ],
                ],
                [
                        'name' => 'make:resource',
                        'description' => 'Scaffold a CRUD resource inside a module (controller, routes, views).',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                                ['name' => '--api', 'description' => 'Generate API routes (no session/CSRF and no HTML assumptions)'],
                                ['name' => '--public-get-only', 'description' => 'Generate GET-only routes (index/show) without session/CSRF'],
                        ],
                ],
                [
                        'name' => 'make:controller',
                        'description' => 'Create a controller class inside a module.',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                                ['name' => '--invokable', 'description' => 'Generate an invokable controller (__invoke)'],
                                ['name' => '--api', 'description' => 'Hint API-style responses in the stub (if available)'],
                        ],
                ],
                [
                        'name' => 'make:service',
                        'description' => 'Create a service class inside a module.',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                        ],
                ],
                [
                        'name' => 'make:view',
                        'description' => 'Create a single view file inside a module from the view stub.',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                        ],
                ],
                [
                        'name' => 'make:views',
                        'description' => 'Create a standard set of CRUD views inside a module (index, show, create, edit, _form).',
                        'options' => [
                                ['name' => '--templates', 'description' => 'Override template source directory', 'accepts' => 'PATH'],
                        ],
                ],
                [
                        'name' => 'make:migration',
                        'description' => 'Create a timestamped migration file (supports --module=Name or positional module).',
                        'options' => [
                                ['name' => '--module', 'description' => 'Target module name for the migration', 'accepts' => 'Name'],
                        ],
                ],
                [
                        'name' => 'make:seeder',
                        'description' => 'Create a seeder class inside a module.',
                        'options' => [],
                ],
                [
                        'name' => 'migrate',
                        'description' => 'Run outstanding migrations.',
                        'options' => [
                                ['name' => '--module', 'description' => 'Limit to a specific module', 'accepts' => 'Name'],
                                ['name' => '--steps', 'description' => 'Limit number of steps', 'accepts' => 'N'],
                                ['name' => '--pretend', 'description' => 'Dry-run without executing'],
                        ],
                ],
                [
                        'name' => 'migrate:rollback',
                        'description' => 'Rollback the last or N batches.',
                        'options' => [
                                ['name' => '--module', 'description' => 'Limit to a specific module', 'accepts' => 'Name'],
                                ['name' => '--steps', 'description' => 'Number of steps to rollback', 'accepts' => 'N'],
                        ],
                ],
                [
                        'name' => 'status',
                        'description' => 'Show migration status.',
                        'options' => [
                                ['name' => '--module', 'description' => 'Limit to a specific module', 'accepts' => 'Name'],
                        ],
                ],
                [
                        'name' => 'seed',
                        'description' => 'Run database seeders.',
                        'options' => [
                                ['name' => '--module', 'description' => 'Limit to a specific module', 'accepts' => 'Name'],
                                ['name' => '--class', 'description' => 'Seeder FQCN to run', 'accepts' => 'FQCN'],
                                ['name' => '--force', 'description' => 'Bypass environment guard'],
                                ['name' => '--env', 'description' => 'Environment name', 'accepts' => 'ENV'],
                        ],
                ],
                // Phase 16: examples commands removed
                [
                        'name' => 'key:generate',
                        'description' => 'Generate and set APP_KEY in .env.',
                        'options' => [
                                ['name' => '--force', 'description' => 'Overwrite existing APP_KEY'],
                        ],
                ],
                [
                        'name' => 'pack',
                        'description' => 'Build an environment-specific deployment bundle (Phase 11 Packer).',
                        'options' => [
                                ['name' => '--env', 'description' => 'Environment: production|development|testing', 'accepts' => 'ENV'],
                                ['name' => '--include-dev', 'description' => 'Include development modules even in production'],
                                ['name' => '--target', 'description' => 'Target: webhost|container', 'accepts' => 'TARGET'],
                                ['name' => '--out', 'description' => 'Output directory (default: ./dist)', 'accepts' => 'PATH'],
                                ['name' => '--dry-run', 'description' => 'Do not copy files; print bundle plan'],
                        ],
                ],
                [
                        'name' => 'route:cache',
                        'description' => 'Compile and cache application routes (stub spec for Phase 11).',
                        'options' => [
                                ['name' => '--out', 'description' => 'Output cache file (default: ./storage/cache/routes.cache.php)', 'accepts' => 'PATH'],
                                ['name' => '--modules', 'description' => 'Modules root (default: ./Modules)', 'accepts' => 'PATH'],
                                ['name' => '--env', 'description' => 'Environment for module filtering', 'accepts' => 'ENV'],
                        ],
                ],
                [
                        'name' => 'route:clear',
                        'description' => 'Delete the compiled routes cache file (stub).',
                        'options' => [
                                ['name' => '--file', 'description' => 'Cache file path (default: ./storage/cache/routes.cache.php)', 'accepts' => 'PATH'],
                        ],
                ],
                [
                        'name' => 'make:routes',
                        'description' => 'Scan a module’s Views and generate appropriate routes (web by default, use --api for stateless).',
                        'options' => [
                                ['name' => '--module', 'description' => 'Target module name (alternative to positional argument)', 'accepts' => 'Name'],
                                ['name' => '--api', 'description' => 'Generate routes without session/CSRF grouping (for API/stateless)'],
                        ],
                ],
        ];
    }

    // 5) Dispatch
    $command = $argv[1] ?? 'help';

    // Persist CLI metadata on every run (cheap) to keep docs in sync
    persistCliMetadata($appRoot, cliCommandRegistry());

    try {
        // Phase 16: examples discovery and installer removed
        switch ($command) {
            case 'help':
            case '--help':
            case '-h':
                echo <<<TXT
        Ishmael CLI (Core distribution)

Usage:
  ish help
  ish make:module <Name> [--templates=PATH] [--api]
  ish make:resource <Module> <Name> [--templates=PATH] [--api] [--public-get-only]
  ish make:controller <Module> <Name> [--invokable] [--templates=PATH]
  ish make:service <Module> <Name> [--templates=PATH]
  ish make:views <Module> <resource> [--templates=PATH]
  ish make:view <Module> <resource>/<view> [--templates=PATH]
  ish make:migration <name> [--module=Name]
  ish make:migration <Module> <name>
  ish make:seeder <Module> <Class>
  ish migrate [--module=Name] [--steps=N] [--pretend]
  ish migrate:rollback [--module=Name] [--steps=N]
  ish status [--module=Name]
  ish seed [--module=Name] [--class=FQCN] [--force] [--env=ENV]
  ish ui:tailwind [--css=resources\\css\\app.css] [--out=public\\assets\\app.css] [--force] [--dry-run] [--no-build]
  ish modules:cache [--env=production|development|testing] [--allow-dev] [--modules=PATH] [--cache=PATH]
  ish modules:clear [--cache=PATH]
  ish route:cache [--out=PATH] [--modules=PATH] [--env=ENV]
  ish route:clear [--file=PATH]
  ish make:routes <Module> [--api]
  ish make:routes --module=Name [--api]
  ish pack --env=production [--include-dev] [--target=webhost|container] [--out=./dist] [--dry-run]

Options:
  --config=PATH      Path to database config (defaults to <appRoot>/config/database.php)
  --templates=PATH   Override template source directory completely
  --app-root=PATH    Override application root (defaults to current working directory)
TXT;
                exit(0);

            case 'tailwind:init':
            case 'tailwind:install':
            case 'ui:tailwind': {
                $dryRun = isset($options['dry-run']);
                $force = isset($options['force']);
                $skipBuild = isset($options['no-build']);
                $cssIn = (string)($options['css'] ?? ('resources' . DIRECTORY_SEPARATOR . 'css' . DIRECTORY_SEPARATOR . 'app.css'));
                $cssOut = (string)($options['out'] ?? ('public' . DIRECTORY_SEPARATOR . 'assets' . DIRECTORY_SEPARATOR . 'app.css'));

                // Helper: run a shell command and stream output
                $run = function(string $cmd) use ($dryRun): void {
                    if ($dryRun) {
                        echo "DRY-RUN: {$cmd}\n";
                        return;
                    }
                    passthru($cmd, $code);
                    if ($code !== 0) {
                        throw new RuntimeException("Command failed ({$code}): {$cmd}");
                    }
                };

                // Preflight: npm and node present
                $checkBin = function(string $bin) use ($run): void {
                    // We deliberately avoid throwing on Windows where 'where' may not exist in restricted envs; try running --version
                    $cmd = $bin . ' -v';
                    ob_start();
                    passthru($cmd, $code);
                    ob_end_clean();
                    if ($code !== 0) {
                        throw new RuntimeException("{$bin} not found or not executable. Please install Node.js and npm and ensure they are in PATH.");
                    }
                };
                $checkBin('node');
                $checkBin('npm');

                // Ensure package.json exists and update scripts
                $pkgPath = $appRoot . DIRECTORY_SEPARATOR . 'package.json';
                $pkg = [];
                if (is_file($pkgPath)) {
                    $pkg = json_decode((string)file_get_contents($pkgPath), true) ?: [];
                } else {
                    $pkg = [
                        'name' => 'ish-app',
                        'private' => true,
                        'version' => '0.0.0',
                    ];
                }
                $pkg['scripts'] = $pkg['scripts'] ?? [];
                // If existing scripts reference the old v3 CLI `tailwindcss`, gently upgrade them to use the v4 CLI package
                foreach (['dev', 'build'] as $scriptName) {
                    if (isset($pkg['scripts'][$scriptName]) && is_string($pkg['scripts'][$scriptName])) {
                        $pkg['scripts'][$scriptName] = str_replace('tailwindcss ', '@tailwindcss/cli ', $pkg['scripts'][$scriptName]);
                    }
                }
                if (!isset($pkg['scripts']['dev'])) {
                    // Tailwind v4 uses the separate CLI package
                    $pkg['scripts']['dev'] = '@tailwindcss/cli -i resources/css/app.css -o public/assets/app.css -w';
                }
                if (!isset($pkg['scripts']['build'])) {
                    $pkg['scripts']['build'] = '@tailwindcss/cli -i resources/css/app.css -o public/assets/app.css --minify';
                }
                $newPkgJson = json_encode($pkg, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n";
                if ($dryRun) {
                    echo "DRY-RUN: write package.json (create or update)\n";
                } else {
                    file_put_contents($pkgPath, (string)$newPkgJson);
                }

                // Install Tailwind v4 requirements: core + CLI
                $run('npm i -D tailwindcss@latest @tailwindcss/cli@latest');

                // Create input CSS with Tailwind and @source for Modules views
                $cssInAbs = $appRoot . DIRECTORY_SEPARATOR . $cssIn;
                $cssDir = dirname($cssInAbs);
                ensureDirectory($cssDir);
                $inputCss = <<<CSS
        @import "tailwindcss";

        /* Tailwind v4 content sources for Ishmael Modules views */
        @source "../../Modules/**/*.{php,html,js,ts,jsx,tsx,vue}";
        CSS;
                if ($dryRun) {
                    echo "DRY-RUN: write {$cssIn} (force=" . ($force ? 'true' : 'false') . ")\n";
                } else {
                    if (file_exists($cssInAbs) && !$force) {
                        // Leave existing file intact
                    } else {
                        file_put_contents($cssInAbs, $inputCss);
                    }
                }

                // Ensure output directory exists
                $cssOutAbs = $appRoot . DIRECTORY_SEPARATOR . $cssOut;
                ensureDirectory(dirname($cssOutAbs));

                // Initial build
                if (!$skipBuild) {
                    // Use npx to run Tailwind CLI
                    $inArg = str_replace('/', DIRECTORY_SEPARATOR, $cssIn);
                    $outArg = str_replace('/', DIRECTORY_SEPARATOR, $cssOut);
                    $cmd = 'npx @tailwindcss/cli -i ' . escapeshellarg($inArg) . ' -o ' . escapeshellarg($outArg) . ' --minify';
                    $run($cmd);
                }

                echo "Tailwind installed and CSS scaffolded.\n";
                echo "- Input: {$cssIn}\n";
                echo "- Output: {$cssOut}\n";
                echo "Tip: add this to your layout head (uncomment):\n<!-- <link rel=\"stylesheet\" href=\"/assets/app.css\"> -->\n";
                exit(0);
            }

            case 'make:module': {
                $name = $argv[2] ?? '';
                if ($name === '') {
                    throw new InvalidArgumentException('Module name is required: ish make:module <Name>');
                }
                $studly = toStudlyCase($name);
                $moduleSlug = strtolower($studly);
                $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $studly;
                $templateRoot = resolveTemplateDir('Module', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);

                // Render-copy template tree: strip .stub suffixes and replace tokens
                $iterator = new RecursiveIteratorIterator(
                        new RecursiveDirectoryIterator($templateRoot, FilesystemIterator::SKIP_DOTS),
                        RecursiveIteratorIterator::SELF_FIRST
                );
                foreach ($iterator as $item) {
                    $rel = $iterator->getSubPathName();
                    $outPath = $dest . DIRECTORY_SEPARATOR . $rel;
                    if ($item->isDir()) {
                        ensureDirectory($outPath);
                        continue;
                    }
                    $contents = file_get_contents($item->getPathname());
                    if ($contents === false) {
                        throw new RuntimeException('Failed to read template file: ' . $item->getPathname());
                    }
                    // Replace well-known tokens
                    $rendered = replaceTokens($contents, [
                            'ModuleName' => $studly,
                            'module' => $moduleSlug,
                    ]);
                    // Drop .stub suffix for destination files
                    if (str_ends_with($outPath, '.stub')) {
                        $outPath = substr($outPath, 0, -5);
                    }
                    // Post-process routes.php to avoid root route collisions and placeholder names
                    if (substr($outPath, -10) === 'routes.php') {
                        // If stub defines a home route at '/', move it to '/{module}' and set name '{module}.home'
                        $rendered = preg_replace(
                                '#\->get\(\s*\'/\'\s*,#',
                                '->get(\'/' . $moduleSlug . '\',',
                                (string)$rendered
                        );
                        // Replace placeholder route names like <module>.home if present
                        $rendered = str_replace('<module>.', $moduleSlug . '.', (string)$rendered);
                        // Ensure any api/health route is also scoped under the module prefix
                        $rendered = preg_replace(
                                '#(\\$router->get\\()\\s*\'/?api/health\'#',
                                '$1\'/' . $moduleSlug . '/api/health\'',
                                (string)$rendered
                        );
                        // If the stub points home to a non-existent BlogHomeController, replace with a simple closure placeholder
                        $homeReplacement = '->get(\'/' . $moduleSlug . '\', function($req, \\Ishmael\\Core\\Http\\Response $res): \\Ishmael\\Core\\Http\\Response { return $res->setBody(\'' . $studly . ' module home\'); })';
                        $rendered = preg_replace(
                                '#->get\(\'/' . preg_quote($moduleSlug, '#') . '\',\\s*\'[^\']*HomeController@index\'\)#',
                                $homeReplacement,
                                (string)$rendered
                        );
                        // Some older stubs accidentally included a second PHP header and an extra closure; keep only the first closure body
                        $firstOpen = strpos($rendered, 'return function (Router $router): void {');
                        if ($firstOpen !== false) {
                            $afterOpen = substr($rendered, $firstOpen);
                            $firstClosePos = strpos($afterOpen, '};');
                            if ($firstClosePos !== false) {
                                $firstBlock = substr($afterOpen, 0, $firstClosePos + 2);
                                // Rebuild minimal file with header and the first block only
                                $headerPos = strpos($rendered, '<?php');
                                $header = $headerPos === false ? '' : substr($rendered, 0, $firstOpen);
                                $rendered = $header . $firstBlock . "\n";
                            }
                        }
                        // If not API-oriented module, hint a CSRF/session group comment for developers
                        if (!isset($options['api'])) {
                            $hint = "\n    // Tip: Web routes typically run with session + CSRF middleware.\n    // You can wrap routes into a group with StartSessionMiddleware then VerifyCsrfToken.\n";
                            // Insert the hint after the opening of the closure
                            $rendered = preg_replace('#(return function \(Router \\$router\): void \{\n)#', '$1' . str_replace('\\', '\\\\', $hint), (string)$rendered, 1);
                        }
                    }
                    writeFile($outPath, $rendered);
                }

                echo 'Module scaffolded at: ' . $dest . PHP_EOL;
                exit(0);
            }

            case 'make:resource': {
                $moduleArg = $argv[2] ?? '';
                $nameArg = $argv[3] ?? '';
                if ($moduleArg === '' || $nameArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:resource <Module> <Name> [--templates=PATH]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $resourceStudly = toStudlyCase($nameArg);
                $resourceLower = strtolower($resourceStudly);
                $resourcesLower = rtrim($resourceLower, 's') !== $resourceLower ? $resourceLower : $resourceLower . 's';
                $isApi = isset($options['api']);
                $publicGetOnly = isset($options['public-get-only']);

                $moduleDir = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly;
                ensureDirectory($moduleDir);

                // 1) Controller
                $resTpl = resolveTemplateDir('Resource', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $ctrlTpl = $resTpl . DIRECTORY_SEPARATOR . 'Controllers' . DIRECTORY_SEPARATOR . 'ResourceController.php.stub';
                if (!is_file($ctrlTpl)) { throw new RuntimeException('Missing Resource controller stub: ' . $ctrlTpl); }
                $ctrlContents = file_get_contents($ctrlTpl);
                if ($ctrlContents === false) { throw new RuntimeException('Failed to read controller stub'); }
                $ctrlContents = replaceTokens($ctrlContents, [
                        'ModuleName' => $moduleStudly,
                        'ResourceName' => $resourceStudly,
                    // Prefer plural resource path usage in controllers
                        'resource' => $resourcesLower,
                        'resources' => $resourcesLower,
                ]);
                // Safety: if stub used singular in render paths, normalize to plural directory
                $ctrlContents = str_replace("'{$resourceLower}/", "'{$resourcesLower}/", $ctrlContents);
                $ctrlDest = $moduleDir . DIRECTORY_SEPARATOR . 'Controllers' . DIRECTORY_SEPARATOR . $resourceStudly . 'Controller.php';
                writeFile($ctrlDest, $ctrlContents);

                // 2) Views
                $views = ['index.php.stub' => 'index.php', 'show.php.stub' => 'show.php', 'create.php.stub' => 'create.php', 'edit.php.stub' => 'edit.php', '_form.php.stub' => '_form.php'];
                foreach ($views as $src => $dst) {
                    // Try plural folder, then singular, then placeholder, then flat
                    $vpCandidates = [
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resourcesLower . DIRECTORY_SEPARATOR . $src,
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resourceLower . DIRECTORY_SEPARATOR . $src,
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . '<resource>' . DIRECTORY_SEPARATOR . $src,
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $src,
                    ];
                    $vp = '';
                    foreach ($vpCandidates as $cand) {
                        if (is_file($cand)) { $vp = $cand; break; }
                    }
                    if ($vp === '') {
                        // Fallback minimal template when no stub is available
                        $title = ucfirst(pathinfo($dst, PATHINFO_FILENAME));
                        $vc = "<h1>{$resourceStudly} {$title}</h1>\n<p>Placeholder view generated by ish.</p>\n";
                    } else {
                        $vc = file_get_contents($vp);
                        if ($vc === false) { throw new RuntimeException('Failed to read view stub: ' . $vp); }
                    }
                    $vc = replaceTokens($vc, [
                            'ModuleName' => $moduleStudly,
                            'ResourceName' => $resourceStudly,
                            'resource' => $resourcesLower, // directory convention uses plural
                            'resources' => $resourcesLower,
                    ]);
                    $dest = $moduleDir . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resourcesLower . DIRECTORY_SEPARATOR . $dst;
                    writeFile($dest, $vc);
                }

                // 3) Routes: append resource routes
                $routesTpl = $resTpl . DIRECTORY_SEPARATOR . 'routes.php.stub';
                if (is_file($routesTpl)) {
                    $rc = file_get_contents($routesTpl);
                    if ($rc === false) { throw new RuntimeException('Failed to read resource routes stub'); }
                    $moduleSlug = strtolower($moduleStudly);
                    $rc = replaceTokens($rc, [
                            'ModuleName' => $moduleStudly,
                            'ResourceName' => $resourceStudly,
                            'resource' => $resourceLower,
                            'resources' => $resourcesLower,
                            'module' => $moduleSlug,
                    ]);
                    // Sanitize: extract only $router-> lines, remove PHP tags/closures, ensure leading '/'
                    $lines = preg_split("#\r?\n#", $rc) ?: [];
                    $routeLines = [];
                    foreach ($lines as $line) {
                        if (strpos($line, '$router->') === false) { continue; }
                        // Extract and normalize the path argument
                        if (preg_match('#(\$router->\w+\()\s*\'([^\']*)\'#', $line, $m)) {
                            $prefix = $m[1];
                            $path = $m[2];
                            // Ensure leading slash
                            if ($path !== '' && $path[0] !== '/') { $path = '/' . $path; }
                            // Prefix with /{module}/ if not already starting with it
                            $modulePrefix = '/' . $moduleSlug;
                            if ($path === '/') {
                                $path = $modulePrefix;
                            } elseif (strpos($path, $modulePrefix . '/') !== 0) {
                                // Avoid double-prefix if the stub already has /blog/... explicitly
                                if (strpos($path, $modulePrefix) !== 0) {
                                    $path = rtrim($modulePrefix, '/') . '/' . ltrim($path, '/');
                                }
                            }
                            // Normalize singular to plural path segment
                            $path = str_replace('/' . $resourceLower . '/', '/' . $resourcesLower . '/', $path);
                            $path = preg_replace('#/' . preg_quote($resourceLower, '#') . '$#', '/' . $resourcesLower, $path) ?? $path;
                            // Rebuild the line with normalized path
                            $line = preg_replace('#(\$router->\w+\()\s*\'([^\']*)\'#', $prefix . "'" . $path . "'", $line, 1);
                        }
                        // Replace placeholder route names like <module>.something
                        $line = str_replace('<module>.', $moduleSlug . '.', (string)$line);
                        // Normalize controller name to <ResourceName>Controller instead of <Module><ResourceName>Controller
                        $line = str_replace($moduleStudly . $resourceStudly . 'Controller', $resourceStudly . 'Controller', (string)$line);
                        $routeLines[] = rtrim($line);
                    }
                    // Build canonical resource routes irrespective of stub quirks
                    $basePath = '/' . $moduleSlug . '/' . $resourcesLower;
                    // Build route lines (escaped $). Respect --public-get-only by omitting POST routes.
                    $lines = [];
                    $lines[] = "\$ROUTER->get('{$basePath}', '" . $resourceStudly . "Controller@index')->name('{$moduleSlug}.{$resourcesLower}.index');";
                    $lines[] = "\$ROUTER->get('{$basePath}/create', '" . $resourceStudly . "Controller@create')->name('{$moduleSlug}.{$resourcesLower}.create');";
                    if (!$publicGetOnly) {
                        $lines[] = "\$ROUTER->post('{$basePath}', '" . $resourceStudly . "Controller@store')->name('{$moduleSlug}.{$resourcesLower}.store');";
                    }
                    $lines[] = "\$ROUTER->get('{$basePath}/{id:int}', '" . $resourceStudly . "Controller@show')->name('{$moduleSlug}.{$resourcesLower}.show');";
                    $lines[] = "\$ROUTER->get('{$basePath}/{id:int}/edit', '" . $resourceStudly . "Controller@edit')->name('{$moduleSlug}.{$resourcesLower}.edit');";
                    if (!$publicGetOnly) {
                        $lines[] = "\$ROUTER->post('{$basePath}/{id:int}', '" . $resourceStudly . "Controller@update')->name('{$moduleSlug}.{$resourcesLower}.update');";
                        $lines[] = "\$ROUTER->post('{$basePath}/{id:int}/delete', '" . $resourceStudly . "Controller@destroy')->name('{$moduleSlug}.{$resourcesLower}.destroy');";
                    }
                    $rc = implode("\n", $lines) . "\n";

                    $routesPath = $moduleDir . DIRECTORY_SEPARATOR . 'routes.php';
                    if (!is_file($routesPath)) {
                        // Bootstrap routes with module routes stub
                        $modTplDir = resolveTemplateDir('Module', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                        $baseRoutes = $modTplDir . DIRECTORY_SEPARATOR . 'routes.php.stub';
                        if (is_file($baseRoutes)) {
                            $base = file_get_contents($baseRoutes) ?: '';
                            $base = replaceTokens($base, ['ModuleName' => $moduleStudly, 'module' => $moduleSlug]);
                            // Avoid root route collision in fresh modules as well
                            $base = preg_replace("#\->get\(\s*'/'\s*,#", "->get('/{$moduleSlug}',", (string)$base);
                            $base = str_replace('<module>.', $moduleSlug . '.', (string)$base);
                            writeFile($routesPath, $base);
                        } else {
                            $bootstrap = '<?php' . "\n" . 'declare(strict_types=1);' . "\n\n" . 'use Ishmael\\Core\\Router;' . "\n\n" . 'return function (Router $router): void {' . "\n" . '};' . "\n";
                            writeFile($routesPath, $bootstrap);
                        }
                    }
                    $existing = file_get_contents($routesPath) ?: '';
                    $hasWrapper = (strpos($existing, 'return function (Router $router): void {') !== false);
                    // If the file is empty or whitespace, treat as no wrapper
                    if (trim($existing) === '') { $hasWrapper = false; }
                    if (!$hasWrapper) {
                        // Build a minimal routes file with module home route and the resource routes
                        $header = '<?php' . "\n" . 'declare(strict_types=1);' . "\n\n" . 'use Ishmael\\Core\\Router;' . "\n\n" . 'return function (Router $router): void {' . "\n";
                        $homeTpl = <<<'TPL'
    $router->get('/%MODULE_SLUG%', function($req, \Ishmael\Core\Http\Response $res): \Ishmael\Core\Http\Response {
        return $res->setBody('%MODULE_STUDLY% module home');
    })->name('%MODULE_SLUG%.home');

TPL;
                        $home = str_replace(
                                ['%MODULE_SLUG%', '%MODULE_STUDLY%'],
                                [$moduleSlug, $moduleStudly],
                                $homeTpl
                        );
                        // Insert resource routes directly (CSRF is enforced globally via middleware; no per-route CSRF groups needed)
                        $body = "    // Resource: {$resourceStudly}\n";
                        $rcIndented = preg_replace('#^#m', '    ', str_replace('$ROUTER', '$router', $rc)) ?? $rc;
                        $updated = $header . $home . $body . $rcIndented . "};\n";
                    } else {
                        // Insert before the last closing "};"
                        $pos = strrpos($existing, '};');
                        if ($pos === false) { $pos = strlen($existing); }
                        $insertion = "\n    // Resource: {$resourceStudly}\n";
                        $rcIndented = preg_replace('#^#m', '    ', str_replace('$ROUTER', '$router', $rc)) ?? $rc;
                        $insertion .= $rcIndented;
                        $updated = substr($existing, 0, $pos) . rtrim("\n" . $insertion) . "\n};\n";
                    }
                    // Final sanitation: ensure leading slashes and module prefix on resource routes
                    // Ensure a leading slash on bare paths and enforce module prefix.
                    // Use single-quoted replacement to keep $1/$2 as backreferences for preg_replace, not PHP.
                    $updated = preg_replace('#(\\\\\$router->\\w+\\()\s*\'([^/][^\']*)\'#', '$1\'/$2\'', (string)$updated);
                    // For the second replace we need {$moduleSlug} interpolation, so escape backreferences in the replacement
                    $updated = preg_replace("#(\\\\\$router->\\w+\\()'/(?!{$moduleSlug})([^']*)#", "\\$1'/$moduleSlug/\\$2", (string)$updated);
                    // Normalize singular segment only when it is a full path segment, avoiding 'post' inside 'posts'
                    $updated = preg_replace("#'/$moduleSlug/{$resourceLower}/#", "'/$moduleSlug/{$resourcesLower}/", (string)$updated);
                    $updated = preg_replace("#'/$moduleSlug/{$resourceLower}'#", "'/$moduleSlug/{$resourcesLower}'", (string)$updated);
                    $updated = str_replace("{$moduleSlug}.{$resourceLower}.", "{$moduleSlug}.{$resourcesLower}.", (string)$updated);
                    writeFile($routesPath, $updated, true);
                }

                echo 'Resource scaffolded: ' . $moduleStudly . '/' . $resourceStudly . PHP_EOL;
                exit(0);
            }

            case 'make:routes': {
                // Accept either positional <Module> or --module=Name
                $moduleArg = isset($options['module']) ? (string)$options['module'] : ($argv[2] ?? '');
                if ($moduleArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:routes <Module> [--api] or ish make:routes --module=Name [--api]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $moduleSlug = strtolower($moduleStudly);
                $isApi = isset($options['api']);
                $moduleDir = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly;
                $viewsDir = $moduleDir . DIRECTORY_SEPARATOR . 'Views';
                if (!is_dir($viewsDir)) {
                    throw new RuntimeException('Views directory not found for module: ' . $viewsDir);
                }
                // Discover resource folders under Views
                $items = scandir($viewsDir) ?: [];
                $resources = [];
                foreach ($items as $item) {
                    if ($item === '.' || $item === '..') { continue; }
                    $path = $viewsDir . DIRECTORY_SEPARATOR . $item;
                    if (is_dir($path)) {
                        $resources[] = strtolower($item);
                    }
                }
                if (empty($resources)) {
                    echo "No resource directories found under Views. Nothing to do.\n";
                    exit(0);
                }
                $routesPath = $moduleDir . DIRECTORY_SEPARATOR . 'routes.php';
                if (!is_file($routesPath)) {
                    // Bootstrap with minimal routes file
                    $bootstrap = '<?php' . "\n" . 'declare(strict_types=1);' . "\n\n" . 'use Ishmael\\Core\\Router;' . "\n\n" . 'return function (Router $router): void {' . "\n" . '};' . "\n";
                    writeFile($routesPath, $bootstrap);
                }
                $existing = file_get_contents($routesPath) ?: '';
                $hasWrapper = (strpos($existing, 'return function (Router $router): void {') !== false);
                if (trim($existing) === '') { $hasWrapper = false; }

                $blocks = [];
                foreach ($resources as $res) {
                    $resDir = $viewsDir . DIRECTORY_SEPARATOR . $res;
                    $files = array_flip(array_map('strtolower', scandir($resDir) ?: []));
                    // Build conventional route set based on available views
                    $resPlural = (str_ends_with($res, 's') ? $res : $res . 's');
                    // Title uses singular form for readability, controllers remain plural to match generated class names
                    $resStudly = toStudlyCase(rtrim($resPlural, 's'));
                    // Controllers are generated with plural resource names (e.g., PostsController, AuthorsController)
                    $controllerStudly = toStudlyCase($resPlural);
                    $basePath = '/' . $moduleSlug . '/' . $resPlural;
                    $lines = [];
                    if (isset($files['index.php'])) {
                        $lines[] = "\$ROUTER->get('{$basePath}', '" . $controllerStudly . "Controller@index')->name('{$moduleSlug}.{$resPlural}.index');";
                    }
                    if (isset($files['create.php'])) {
                        $lines[] = "\$ROUTER->get('{$basePath}/create', '" . $controllerStudly . "Controller@create')->name('{$moduleSlug}.{$resPlural}.create');";
                        $lines[] = "\$ROUTER->post('{$basePath}', '" . $controllerStudly . "Controller@store')->name('{$moduleSlug}.{$resPlural}.store');";
                    }
                    if (isset($files['show.php'])) {
                        $lines[] = "\$ROUTER->get('{$basePath}/{id:int}', '" . $controllerStudly . "Controller@show')->name('{$moduleSlug}.{$resPlural}.show');";
                        // Back-compat and tutorial alignment: add slug-based public show route for Posts
                        if ($resPlural === 'posts') {
                            $lines[] = "\$ROUTER->get('/{$moduleSlug}/p/{slug}', '" . $controllerStudly . "Controller@show')->name('{$moduleSlug}.{$resPlural}.show.slug');";
                        }
                    }
                    if (isset($files['edit.php'])) {
                        $lines[] = "\$ROUTER->get('{$basePath}/{id:int}/edit', '" . $controllerStudly . "Controller@edit')->name('{$moduleSlug}.{$resPlural}.edit');";
                        $lines[] = "\$ROUTER->post('{$basePath}/{id:int}', '" . $controllerStudly . "Controller@update')->name('{$moduleSlug}.{$resPlural}.update');";
                        $lines[] = "\$ROUTER->post('{$basePath}/{id:int}/delete', '" . $controllerStudly . "Controller@destroy')->name('{$moduleSlug}.{$resPlural}.destroy');";
                    }
                    if (!empty($lines)) {
                        $blocks[] = [
                                'title' => 'Resource: ' . $resStudly,
                                'content' => implode("\n", $lines) . "\n",
                        ];
                    }
                }
                if (empty($blocks)) {
                    echo "Found no recognizable CRUD view sets. Nothing to do.\n";
                    exit(0);
                }

                if (!$hasWrapper) {
                    $header = '<?php' . "\n" . 'declare(strict_types=1);' . "\n\n" . 'use Ishmael\\Core\\Router;' . "\n\n" . 'return function (Router $router): void {' . "\n";
                    $homeTpl = <<<'TPL'
    $router->get('/%MODULE_SLUG%', function($req, \\Ishmael\\Core\\Http\\Response $res): \\Ishmael\\Core\\Http\\Response {
        return $res->setBody('%MODULE_STUDLY% module home');
    })->name('%MODULE_SLUG%.home');

TPL;
                    $home = str_replace(['%MODULE_SLUG%', '%MODULE_STUDLY%'], [$moduleSlug, $moduleStudly], $homeTpl);
                    $body = '';
                    foreach ($blocks as $b) {
                        $rcIndented = preg_replace('#^#m', '    ', str_replace('$ROUTER', '$router', $b['content'])) ?? $b['content'];
                        $body .= "    // {$b['title']}\n" . $rcIndented;
                    }
                    // CSRF is enforced globally via middleware in config/app.php; no CSRF group wrapping here
                    $updated = $header . $home . $body . "};\n";
                    writeFile($routesPath, $updated, true);
                } else {
                    $pos = strrpos($existing, '};');
                    if ($pos === false) { $pos = strlen($existing); }
                    $insertion = "\n";
                    foreach ($blocks as $b) {
                        $rcIndented = preg_replace('#^#m', '    ', str_replace('$ROUTER', '$router', $b['content'])) ?? $b['content'];
                        $insertion .= "    // {$b['title']}\n" . $rcIndented;
                    }
                    $updated = substr($existing, 0, $pos) . rtrim("\n" . $insertion) . "\n};\n";
                    writeFile($routesPath, $updated, true);
                }

                echo 'Routes generated for module: ' . $moduleStudly . PHP_EOL;
                exit(0);
            }

            case 'make:view': {
                $moduleArg = $argv[2] ?? '';
                $pathArg = $argv[3] ?? '';
                if ($moduleArg === '' || $pathArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:view <Module> <resource>/<view> [--templates=PATH]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $parts = explode('/', str_replace('\\', '/', $pathArg));
                if (count($parts) < 2) {
                    throw new InvalidArgumentException('View path must be of the form <resource>/<view>');
                }
                $resource = strtolower($parts[0]);
                $view = strtolower($parts[1]);
                $tplDir = resolveTemplateDir('View', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $stub = $tplDir . DIRECTORY_SEPARATOR . 'view.php.stub';
                if (!is_file($stub)) { throw new RuntimeException('Missing view stub: ' . $stub); }
                $contents = file_get_contents($stub);
                if ($contents === false) { throw new RuntimeException('Failed to read view stub'); }
                $contents = replaceTokens($contents, [
                        'ModuleName' => $moduleStudly,
                        'resource' => $resource,
                        'view' => $view,
                ]);
                $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resource . DIRECTORY_SEPARATOR . $view . '.php';
                writeFile($dest, $contents);
                echo 'View created at: ' . $dest . PHP_EOL;
                exit(0);
            }

            case 'make:views': {
                // Generate the standard CRUD set of views: index, show, create, edit, _form
                $moduleArg = $argv[2] ?? '';
                $resourceArg = $argv[3] ?? '';
                if ($moduleArg === '' || $resourceArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:views <Module> <resource> [--templates=PATH]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $resourceLower = strtolower($resourceArg);
                // Reuse Resource view stubs bundle
                $resTpl = resolveTemplateDir('Resource', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $views = ['index.php.stub' => 'index.php', 'show.php.stub' => 'show.php', 'create.php.stub' => 'create.php', 'edit.php.stub' => 'edit.php', '_form.php.stub' => '_form.php'];
                foreach ($views as $src => $dst) {
                    $candidates = [
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . 'resource' . DIRECTORY_SEPARATOR . $src,
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resourceLower . DIRECTORY_SEPARATOR . $src,
                            $resTpl . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $src,
                    ];
                    $stubPath = '';
                    foreach ($candidates as $cand) {
                        if (is_file($cand)) { $stubPath = $cand; break; }
                    }
                    $contents = '';
                    if ($stubPath !== '') {
                        $contents = (string)file_get_contents($stubPath);
                    } else {
                        $title = ucfirst(pathinfo($dst, PATHINFO_FILENAME));
                        $contents = "<h1>" . ucfirst($resourceLower) . " {$title}</h1>\n<p>Placeholder view generated by ish.</p>\n";
                    }
                    $contents = replaceTokens($contents, [
                            'ModuleName' => $moduleStudly,
                            'resource' => $resourceLower,
                            'resources' => $resourceLower . 's',
                    ]);
                    $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly . DIRECTORY_SEPARATOR . 'Views' . DIRECTORY_SEPARATOR . $resourceLower . DIRECTORY_SEPARATOR . $dst;
                    writeFile($dest, $contents);
                }
                echo 'Views created for resource: ' . $moduleStudly . '/' . $resourceLower . PHP_EOL;
                exit(0);
            }

            case 'make:controller': {
                $moduleArg = $argv[2] ?? '';
                $nameArg = $argv[3] ?? '';
                if ($moduleArg === '' || $nameArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:controller <Module> <Name> [--invokable] [--templates=PATH]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $nameStudly = toStudlyCase($nameArg);
                $ctrlTplDir = resolveTemplateDir('Controller', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $invokable = isset($options['invokable']);
                $stubFile = $ctrlTplDir . DIRECTORY_SEPARATOR . ($invokable ? 'Controller.invokable.php.stub' : 'Controller.php.stub');
                if (!is_file($stubFile)) {
                    // Fallback to a minimal inline stub
                    $contents = "<?php\ndeclare(strict_types=1);\n\nnamespace Modules\\{$moduleStudly}\\Controllers;\n\nuse Ishmael\\Core\\Controller;\n\nfinal class {$nameStudly}Controller extends Controller\n{\n    public function index(): string\n    {\n        return \$this->json(['ok' => true, 'controller' => '{$nameStudly}Controller@index']);\n    }\n}\n";
                } else {
                    $contents = (string)file_get_contents($stubFile);
                    $contents = replaceTokens($contents, [
                            'ModuleName' => $moduleStudly,
                            'Name' => $nameStudly,
                    ]);
                }
                $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly . DIRECTORY_SEPARATOR . 'Controllers' . DIRECTORY_SEPARATOR . $nameStudly . 'Controller.php';
                writeFile($dest, $contents);
                echo 'Controller created at: ' . $dest . PHP_EOL;
                exit(0);
            }

            case 'make:service': {
                $moduleArg = $argv[2] ?? '';
                $nameArg = $argv[3] ?? '';
                if ($moduleArg === '' || $nameArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:service <Module> <Name> [--templates=PATH]');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $nameStudly = toStudlyCase($nameArg);
                $svcTplDir = resolveTemplateDir('Service', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $stubFile = $svcTplDir . DIRECTORY_SEPARATOR . 'Service.php.stub';
                if (!is_file($stubFile)) {
                    $contents = "<?php\ndeclare(strict_types=1);\n\nnamespace Modules\\{$moduleStudly}\\Services;\n\nfinal class {$nameStudly}Service\n{\n    public function __construct()\n    {\n    }\n}\n";
                } else {
                    $contents = (string)file_get_contents($stubFile);
                    $contents = replaceTokens($contents, [
                            'ModuleName' => $moduleStudly,
                            'Name' => $nameStudly,
                    ]);
                }
                $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly . DIRECTORY_SEPARATOR . 'Services' . DIRECTORY_SEPARATOR . $nameStudly . 'Service.php';
                writeFile($dest, $contents);
                echo 'Service created at: ' . $dest . PHP_EOL;
                exit(0);
            }

            case 'make:migration': {
                // Support both forms:
                //  - ish make:migration <name> [--module=Name]
                //  - ish make:migration <Module> <name>
                $arg2 = $argv[2] ?? '';
                $arg3 = $argv[3] ?? '';
                $module = $options['module'] ?? null;
                $nameArg = '';
                if ($module !== null) {
                    $nameArg = $arg2;
                } elseif ($arg3 !== '') {
                    $module = $arg2;
                    $nameArg = $arg3;
                } else {
                    $nameArg = $arg2;
                }
                if (trim($nameArg) === '') {
                    throw new InvalidArgumentException('Migration name is required: ish make:migration <name> [--module=Name] or ish make:migration <Module> <name>');
                }
                // Validate module if provided
                if ($module !== null) {
                    $m = (string)$module;
                    if (!preg_match('/^[A-Za-z0-9]+$/', $m)) {
                        throw new InvalidArgumentException('Invalid module name. Use alphanumeric characters only (StudlyCaps preferred).');
                    }
                }
                // Derive class name from original input (StudlyCase)
                $className = toStudlyCase($nameArg);
                // Build sanitized filename segment from raw input
                $sanitized = preg_replace('/[^A-Za-z0-9]+/', '_', (string)$nameArg);
                $sanitized = preg_replace('/_+/', '_', (string)$sanitized);
                $sanitized = trim((string)$sanitized, '_');
                if ($sanitized === '') {
                    throw new InvalidArgumentException('Migration name must contain alphanumeric characters.');
                }
                // Resolve target directory
                $targetModule = $module ? toStudlyCase((string)$module) : null;
                if ($targetModule) {
                    $dir = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $targetModule . DIRECTORY_SEPARATOR . 'Database' . DIRECTORY_SEPARATOR . 'Migrations';
                } else {
                    $dir = $appRoot . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'Database' . DIRECTORY_SEPARATOR . 'Migrations';
                }
                ensureDirectory($dir);
                // Ensure unique timestamp without adding suffixes
                $path = '';
                do {
                    $timestamp = date('YmdHis');
                    $fileName = sprintf('%s_%s.php', $timestamp, $sanitized);
                    $path = $dir . DIRECTORY_SEPARATOR . $fileName;
                    if (file_exists($path)) { usleep(200000); } // 200ms then retry until next second
                } while (file_exists($path));

                $contents = createMigrationContent($className);
                writeFile($path, $contents);

                // Post-generation validation: match discovery regex
                $ok = (bool)preg_match('/^\d{14}_.+\.php$/', $fileName);
                $discoverable = $ok ? ' (discoverable)' : ' (warning: not discoverable)';
                echo 'Created: ' . $path . $discoverable . PHP_EOL;
                if (!$ok) { exit(2); }
                exit(0);
            }

            // Ensure a basic module Home controller exists when creating a module
            // Injected after make:view case to avoid disrupting switch formatting
            case '__ensure_module_home__': {
                // no-op placeholder
                exit(0);
            }

            case 'modules:cache': {
                $modulesDir = isset($options['modules']) ? (string)$options['modules'] : ($appRoot . DIRECTORY_SEPARATOR . 'Modules');
                $env = isset($options['env']) ? (string)$options['env'] : ((getenv('APP_ENV') ?: 'development'));
                $allowDev = isset($options['allow-dev']) ? true : ((bool)(getenv('ALLOW_DEV_MODULES') ?: false));
                $cachePath = isset($options['cache']) ? (string)$options['cache'] : ($appRoot . DIRECTORY_SEPARATOR . 'storage' . DIRECTORY_SEPARATOR . 'cache' . DIRECTORY_SEPARATOR . 'modules.cache.json');
                ensureDirectory(dirname($cachePath));
                ModuleManager::discover($modulesDir, [
                        'appEnv' => $env,
                        'allowDevModules' => $allowDev,
                        'cachePath' => $cachePath,
                ]);
                ModuleManager::writeCache($cachePath);
                echo 'Modules cache written to: ' . $cachePath . PHP_EOL;
                exit(0);
            }

            case 'modules:clear': {
                $cachePath = isset($options['cache']) ? (string)$options['cache'] : ($appRoot . DIRECTORY_SEPARATOR . 'storage' . DIRECTORY_SEPARATOR . 'cache' . DIRECTORY_SEPARATOR . 'modules.cache.json');
                ModuleManager::clearCache($cachePath);
                echo 'Modules cache cleared: ' . $cachePath . PHP_EOL;
                exit(0);
            }

            case 'route:cache': {
                // Stub implementation: discover modules and serialize a compact table from any array-based routes.
                $modulesDir = isset($options['modules']) ? (string)$options['modules'] : ($appRoot . DIRECTORY_SEPARATOR . 'Modules');
                $env = isset($options['env']) ? (string)$options['env'] : ((getenv('APP_ENV') ?: 'development'));
                $outPath = isset($options['out']) ? (string)$options['out'] : ($appRoot . DIRECTORY_SEPARATOR . 'storage' . DIRECTORY_SEPARATOR . 'cache' . DIRECTORY_SEPARATOR . 'routes.cache.php');
                ensureDirectory(dirname($outPath));

                // Discover without executing closures. We will only serialize routes provided as arrays.
                ModuleManager::discover($modulesDir, [
                        'appEnv' => $env,
                        'allowDevModules' => (bool)(getenv('ALLOW_DEV_MODULES') ?: false),
                ]);

                $compiled = [];
                foreach (ModuleManager::$modules as $name => $mod) {
                    $routes = $mod['routes'] ?? [];
                    if (is_array($routes) && !empty($routes)) {
                        foreach ($routes as $r) {
                            if (is_array($r)) {
                                $compiled[] = $r;
                            }
                        }
                    }
                }

                $php = "<?php\n/**\n * Fast-load route table (stub). Generated by `ish route:cache`.\n * This file may be extended in a future phase to include compiled closures.\n * @return array<int, array<string, mixed>>\n */\nreturn " . var_export($compiled, true) . ";\n";
                writeFile($outPath, $php, true);
                echo 'Routes cache written to: ' . $outPath . ' (entries: ' . count($compiled) . ')' . PHP_EOL;
                exit(0);
            }

            case 'route:clear': {
                $filePath = isset($options['file']) ? (string)$options['file'] : ($appRoot . DIRECTORY_SEPARATOR . 'storage' . DIRECTORY_SEPARATOR . 'cache' . DIRECTORY_SEPARATOR . 'routes.cache.php');
                if (is_file($filePath)) {
                    @unlink($filePath);
                    echo 'Routes cache cleared: ' . $filePath . PHP_EOL;
                } else {
                    echo 'No routes cache to clear at: ' . $filePath . PHP_EOL;
                }
                exit(0);
            }

            case 'make:seeder': {
                $moduleArg = $argv[2] ?? '';
                $classArg = $argv[3] ?? '';
                if ($moduleArg === '' || $classArg === '') {
                    throw new InvalidArgumentException('Usage: ish make:seeder <Module> <Class>');
                }
                $moduleStudly = toStudlyCase($moduleArg);
                $classStudly = toStudlyCase($classArg);
                $tplDir = resolveTemplateDir('Seeder', $appRoot, isset($options['templates']) ? (string)$options['templates'] : null);
                $stub = $tplDir . DIRECTORY_SEPARATOR . 'seeder.php.stub';
                if (!is_file($stub)) { throw new RuntimeException('Missing seeder stub: ' . $stub); }
                $contents = file_get_contents($stub);
                if ($contents === false) { throw new RuntimeException('Failed to read seeder stub'); }
                $contents = replaceTokens($contents, [
                        'ModuleName' => $moduleStudly,
                        'ClassName' => $classStudly,
                ]);
                $dest = $appRoot . DIRECTORY_SEPARATOR . 'Modules' . DIRECTORY_SEPARATOR . $moduleStudly . DIRECTORY_SEPARATOR . 'Database' . DIRECTORY_SEPARATOR . 'Seeders' . DIRECTORY_SEPARATOR . $classStudly . '.php';
                writeFile($dest, $contents);
                echo 'Seeder created at: ' . $dest . PHP_EOL;
                exit(0);
            }

            case 'migrate': {
                $module  = $options['module'] ?? null;
                $steps   = isset($options['steps']) ? (int)$options['steps'] : 0;
                $pretend = isset($options['pretend']) ? (bool)filter_var((string)$options['pretend'], FILTER_VALIDATE_BOOL) : false;
                $migrator = new Migrator(Database::adapter());
                $migrator->migrate($module ? (string)$module : null, $steps, $pretend);
                echo 'Migrations complete' . PHP_EOL;
                exit(0);
            }

            case 'migrate:rollback': {
                $module = $options['module'] ?? null;
                $steps  = isset($options['steps']) ? (int)$options['steps'] : 1;
                $migrator = new Migrator(Database::adapter());
                $migrator->rollback($module ? (string)$module : null, $steps);
                echo 'Rollback complete' . PHP_EOL;
                exit(0);
            }

            case 'status': {
                $module = $options['module'] ?? null;
                $migrator = new Migrator(Database::adapter());
                $status = $migrator->status($module ? (string)$module : null);
                echo json_encode($status, JSON_PRETTY_PRINT) . PHP_EOL;
                exit(0);
            }

            case 'seed': {
                $module = $options['module'] ?? null;
                $class  = $options['class'] ?? null;
                $force  = isset($options['force']) ? (bool)filter_var((string)$options['force'], FILTER_VALIDATE_BOOL) : false;
                $env    = $options['env'] ?? null;
                $seeder = new SeedManager(Database::adapter());
                $seeder->seed($module ? (string)$module : null, $class ? (string)$class : null, false, $env ? (string)$env : null, $force);
                echo 'Seeding complete' . PHP_EOL;
                exit(0);
            }

            // Phase 16: examples commands removed

            case 'key:generate': {
                $force = isset($options['force']) ? (bool)filter_var((string)$options['force'], FILTER_VALIDATE_BOOL) : false;
                $envPath = $appRoot . DIRECTORY_SEPARATOR . '.env';
                if (!is_file($envPath)) {
                    // create a minimal .env if missing
                    $tpl = "APP_NAME=Ishmael\nAPP_ENV=development\nAPP_DEBUG=true\nAPP_URL=http://localhost\n";
                    writeFile($envPath, $tpl, true);
                }
                $contents = file_get_contents($envPath);
                if ($contents === false) {
                    throw new RuntimeException('Unable to read .env at ' . $envPath);
                }
                $hasKey = preg_match('/^APP_KEY=.*$/m', $contents) === 1;
                if ($hasKey && !$force) {
                    echo ".env already has APP_KEY. Use --force to rotate.\n";
                    exit(0);
                }
                $key = 'base64:' . base64_encode(random_bytes(32));
                if ($hasKey) {
                    $contents = preg_replace('/^APP_KEY=.*$/m', 'APP_KEY=' . $key, $contents) ?? $contents;
                } else {
                    $contents .= (str_ends_with($contents, "\n") ? '' : "\n") . 'APP_KEY=' . $key . "\n";
                }
                $bytes = file_put_contents($envPath, $contents);
                if ($bytes === false) {
                    throw new RuntimeException('Failed to write .env at ' . $envPath);
                }
                echo "Application key set successfully.\n";
                exit(0);
            }

            case 'pack': {
                // Minimal Packer wiring per Phase 11 (Milestone 3)
                $env = isset($options['env']) ? (string)$options['env'] : ((string)(getenv('APP_ENV') ?: 'development'));
                $includeDev = isset($options['include-dev']);
                $target = isset($options['target']) ? (string)$options['target'] : 'webhost';
                $out = isset($options['out']) ? (string)$options['out'] : ($appRoot . DIRECTORY_SEPARATOR . 'dist');
                $dry = isset($options['dry-run']);

                $packer = new \Ishmael\Core\Packer($appRoot);
                $packer->configure($env, $includeDev, $target, $out, $dry);
                $manifest = $packer->pack();

                if ($dry) {
                    echo "[DRY-RUN] ish pack plan (" . ($manifest['env'] ?? $env) . ")\n";
                    $files = $manifest['files'] ?? [];
                    foreach ($files as $f) {
                        $p = is_array($f) && isset($f['path']) ? (string)$f['path'] : (string)$f;
                        echo " - " . $p . "\n";
                    }
                } else {
                    echo "Bundle created successfully. Manifest: " . ($manifest['env'] ?? $env) . ", files: " . count($manifest['files'] ?? []) . "\n";
                }
                exit(0);
            }

            default:
                fwrite(STDERR, 'Unknown command: ' . $command . PHP_EOL . PHP_EOL);
                fwrite(STDERR, "Run 'ish help' for usage.\n");
                exit(1);
        }
    } catch (Throwable $e) {
        fwrite(STDERR, '[Error] ' . $e->getMessage() . PHP_EOL);
        exit(1);
    }
